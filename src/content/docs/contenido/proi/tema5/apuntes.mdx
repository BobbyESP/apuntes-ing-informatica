---
title: Tema 5 - Programaci√≥n Modular
description: En este tema se aborda la programaci√≥n modular, que consiste en dividir un programa en partes m√°s peque√±as llamadas m√≥dulos o subprogramas. Se explican los conceptos de funciones y procedimientos, as√≠ como el paso de par√°metros por valor y por referencia. Tambi√©n se aborda el uso de variables locales y globales, la recursividad y las bibliotecas.
---
## üßÆ Funciones y Procedimientos 

La programaci√≥n modular implica dividir un programa en partes m√°s peque√±as llamadas **m√≥dulos o subprogramas**. Estos m√≥dulos son independientes entre s√≠, lo que permite trabajar en ellos de forma paralela y modificarlos sin afectar a los dem√°s. 

Existen dos tipos de subprogramas:

* **Funciones:** Realizan una tarea espec√≠fica y **devuelven un valor** al programa principal.
* **Procedimientos:** Realizan una tarea espec√≠fica pero **no devuelven un valor**. 

La utilizaci√≥n de subprogramas facilita la **reutilizaci√≥n del c√≥digo** y disminuye la complejidad del programa, lo que lo hace m√°s legible y manejable.

## üó£Ô∏è Declaraci√≥n e Invocaci√≥n de Funciones 

Para utilizar una funci√≥n, primero hay que **declararla**. Esto implica definir su nombre, el tipo de dato que devuelve, y los par√°metros que recibe como entrada. 

La **invocaci√≥n** de una funci√≥n se realiza desde el programa principal u otro subprograma. Para invocar una funci√≥n, se escribe su nombre seguido de los par√°metros actuales entre par√©ntesis.

**Ejemplo en C++:**

```c++ frame="terminal"
// Declaraci√≥n de una funci√≥n que calcula el valor absoluto de un n√∫mero
int calcularAbsoluto (int x) {
  if ( x < 0 ) {
    return -1 * x;
  } else {
    return x;
  }
}

// Invocaci√≥n de la funci√≥n
int valorAbsoluto = calcularAbsoluto(-5); 
```

En este ejemplo, la funci√≥n `calcularAbsoluto` recibe un entero como par√°metro y devuelve su valor absoluto. La funci√≥n se invoca en la l√≠nea `int valorAbsoluto = calcularAbsoluto(-5)`, pasando -5 como argumento. El valor devuelto por la funci√≥n (5) se almacena en la variable `valorAbsoluto`.

## üì® Paso de Par√°metros 

Los par√°metros son variables que se utilizan para pasar informaci√≥n entre el programa principal y los subprogramas. Existen dos m√©todos principales para pasar par√°metros: **por valor** y **por referencia**.

### üì¶ Paso por Valor 

En el paso por valor, se crea una **copia del valor** del par√°metro actual en la memoria. La funci√≥n trabaja con esta copia, por lo que los cambios que se produzcan en el par√°metro dentro de la funci√≥n **no afectan** al par√°metro original.

### üìå Paso por Referencia

En el paso por referencia, se pasa la **direcci√≥n de memoria** del par√°metro actual a la funci√≥n. Esto permite a la funci√≥n acceder y **modificar** el valor del par√°metro original.

**Ejemplo en C++:**

```c++ frame="terminal"
// Paso por valor
void intercambiarPorValor(int a, int b) {
  int temp = a;
  a = b;
  b = temp;
}

// Paso por referencia
void intercambiarPorReferencia(int &a, int &b) {
  int temp = a;
  a = b;
  b = temp;
}

int main() {
  int x = 10;
  int y = 20;

  intercambiarPorValor(x, y); // No se intercambian los valores
  cout << "x: " << x << ", y: " << y << endl; // Salida: x: 10, y: 20

  intercambiarPorReferencia(x, y); // Se intercambian los valores
  cout << "x: " << x << ", y: " << y << endl; // Salida: x: 20, y: 10

  return 0;
}
```

En este ejemplo, la funci√≥n `intercambiarPorValor` recibe dos enteros por valor, por lo que los cambios que realiza en las variables `a` y `b` no se reflejan en las variables `x` e `y` del programa principal. Por otro lado, la funci√≥n `intercambiarPorReferencia` recibe dos enteros por referencia, por lo que los cambios que realiza en las variables `a` y `b` s√≠ se reflejan en las variables `x` e `y` del programa principal.

## üåé Variables Locales y Globales

* **Variables locales:** Se declaran dentro de una funci√≥n o un bloque de c√≥digo, y su **√°mbito** se limita a esa funci√≥n o bloque.
* **Variables globales:** Se declaran fuera de cualquier funci√≥n, y su **√°mbito** es todo el programa.

Es importante tener en cuenta que el uso excesivo de variables globales puede **disminuir la legibilidad** del c√≥digo y provocar **efectos colaterales**.

Si por alg√∫n motivo (no recomendado) tenemos que llamar a una variable global con el mismo nombre que una variable local, podemos hacerlo utilizando el operador de resoluci√≥n de √°mbito `::`.

**Ejemplo en C++:**

```c++ frame="terminal"
#include <iostream>
using namespace std;

int x = 10; // Variable global

void funcion() {
  int x = 20; // Variable local
  cout << "Variable local: " << x << endl; // Salida: 20
  cout << "Variable global: " << ::x << endl; // Salida: 10
}
```

## üîÑ Recursividad

La recursividad ocurre cuando una funci√≥n **se llama a s√≠ misma**. La recursividad puede ser una t√©cnica √∫til para resolver ciertos tipos de problemas, pero es importante usarla con precauci√≥n y cuando sea estrictamente necesario, ya que puede llevar a un **consumo excesivo de memoria** si no se implementa correctamente.

## üìö Bibliotecas

Las bibliotecas son archivos que contienen el c√≥digo de un conjunto de funciones y procedimientos. El uso de bibliotecas permite **reutilizar c√≥digo** y evitar la codificaci√≥n de operaciones comunes.