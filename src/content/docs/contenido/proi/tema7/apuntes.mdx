---
title: Tema 7 - Uniones y estructuras
description: Uniones y estructuras (conjunto de datos) en C/C++, diferencias, uso, ventajas y desventajas...
---

## ðŸ“‚ Estructuras

Las estructuras en C/C++ son tipos de datos compuestos que permiten agrupar datos heterogÃ©neos bajo un mismo identificador. Este enfoque es Ãºtil cuando se desea trabajar con informaciÃ³n que estÃ¡ relacionada lÃ³gicamente pero que puede ser de diferentes tipos, como nÃºmeros, cadenas de texto o incluso otras estructuras. Cada uno de estos datos agrupados recibe el nombre de **campo o miembro**.

### CaracterÃ­sticas principales

Las estructuras presentan varias ventajas y caracterÃ­sticas clave que las hacen Ãºtiles para organizar datos complejos:

- **Diversidad de tipos:** Cada campo puede ser de un tipo diferente, como nÃºmeros enteros, flotantes, caracteres o incluso otras estructuras.
- **IdentificaciÃ³n Ãºnica:** Cada campo dentro de la estructura debe tener un nombre Ãºnico que permita su acceso individual.
- **Orden fijo:** Los campos se definen en un orden especÃ­fico dentro de la estructura, y este orden se respeta en memoria.
- **ReutilizaciÃ³n:** Una vez definida, la estructura puede ser utilizada para declarar mÃºltiples variables del mismo tipo.

### DefiniciÃ³n y uso

La declaraciÃ³n de una estructura en C++ sigue esta sintaxis bÃ¡sica:

```c++ frame="terminal"
struct NombreEstructura {
    tipo1 nombreMiembro1;
    tipo2 nombreMiembro2;
    ...
    tipoN nombreMiembroN;
};

NombreEstructura nombreVariable; // DeclaraciÃ³n de variables
```

Por ejemplo, si queremos modelar informaciÃ³n sobre un libro, podemos definir una estructura llamada `Libro` como sigue:

#### Ejemplo

```c++ frame="terminal"
struct Libro {
    char titulo[100];
    char autor[100];
    float precio;
    int numPaginas;
};

Libro miLibro;
```

En este caso, `miLibro` es una variable que contiene informaciÃ³n como el tÃ­tulo, el autor, el precio y el nÃºmero de pÃ¡ginas de un libro. Cada uno de estos datos se accede utilizando el operador `.`.

### Estructuras anidadas

En ocasiones, los datos dentro de una estructura pueden estar relacionados de forma jerÃ¡rquica. Para estos casos, es posible definir estructuras dentro de otras estructuras. Esto se conoce como **estructuras anidadas**.

#### Ejemplo de estructura anidada

```c++ frame="terminal"
struct Fecha {
    int dia;
    int mes;
    int aÃ±o;
};

struct Libro {
    char titulo[100];
    char autor[100];
    Fecha fechaPublicacion;
    float precio;
    int numPaginas;
};

Libro miLibro;
```

AquÃ­, `miLibro` incluye un campo `fechaPublicacion`, que a su vez es una estructura `Fecha` con tres campos: `dia`, `mes` y `aÃ±o`. Esto permite organizar datos complejos de forma clara y estructurada.

## ðŸ”€ Uniones

Las uniones en C/C++ son similares a las estructuras, pero con una diferencia fundamental: todos los miembros de una uniÃ³n comparten el mismo espacio de memoria. Esto significa que solo un miembro de la uniÃ³n puede almacenar datos en un momento dado, lo que las hace ideales para ahorrar memoria cuando se tiene la certeza de que solo se necesita un dato activo a la vez.

### CaracterÃ­sticas principales

- **Memoria compartida:** Los miembros de la uniÃ³n utilizan el mismo espacio en memoria, cuyo tamaÃ±o serÃ¡ igual al del miembro mÃ¡s grande.
- **Exclusividad:** Solo un miembro puede contener un valor vÃ¡lido en un momento dado.
- **ModificaciÃ³n mutua:** Cambiar el valor de un miembro afecta al contenido de los demÃ¡s, ya que todos ocupan la misma posiciÃ³n en memoria.

### DefiniciÃ³n y uso

La declaraciÃ³n de una uniÃ³n sigue una sintaxis similar a la de una estructura:

```c++
union NombreUnion {
    tipo1 nombreMiembro1;
    tipo2 nombreMiembro2;
    ...
    tipoN nombreMiembroN;
};

NombreUnion nombreVariable; // DeclaraciÃ³n de variables
```

#### Ejemplo de uniÃ³n

```c++
union Temperatura {
    float cel;
    float fah;
    float kel;
};

Temperatura temperaturaHoy;
```

En este ejemplo, `temperaturaHoy` puede almacenar un valor en Celsius, Fahrenheit o Kelvin, pero solo uno de ellos estarÃ¡ activo en un momento dado.

## âš™ï¸ Operaciones

### Acceso a los miembros

Para acceder a los miembros de una estructura o uniÃ³n, utilizamos el operador `.` cuando trabajamos directamente con la variable o `->` si trabajamos con un puntero.

#### Ejemplo con acceso directo

```c++
miLibro.precio = 59.8;
cout << miLibro.titulo;
```

#### Ejemplo con punteros

```c++
Libro *ptrLibro = &miLibro;
ptrLibro->precio = 45.5;
```

### AsignaciÃ³n

En C++, es posible asignar valores a una estructura de tres maneras principales:

1. **AsignaciÃ³n global:** Copiar todos los valores de una estructura a otra del mismo tipo.

   ```c++
   otroLibro = miLibro;
   ```

2. **AsignaciÃ³n individual:** Modificar los valores campo a campo.

   ```c++
   miLibro.precio = 59.8;
   otroLibro.fechaPublicacion.dia = 26;
   ```

3. **InicializaciÃ³n directa:** Proporcionar valores a todos los campos durante la declaraciÃ³n.

   ```c++
   Libro otroLibro = {"La NiÃ±a", "Carmen Mola", 28.5, 327};
   ```

### Lectura y escritura

Las operaciones de lectura y escritura tambiÃ©n se realizan campo a campo:

```c++
cin >> miLibro.fechaPublicacion.mes;
cout << miLibro.titulo;
```

## ðŸ› ï¸ Estructuras como parÃ¡metros

Las estructuras pueden ser pasadas a funciones de dos maneras principales:

- **Por valor:** Se pasa una copia de la estructura, por lo que los cambios realizados dentro de la funciÃ³n no afectan a la estructura original.
- **Por referencia:** Se pasa la direcciÃ³n de la estructura, lo que permite modificar directamente los valores originales.

#### Ejemplo con funciones

```c++ frame="terminal"
#include <iostream>
using namespace std;

struct Persona {
    char nombre[100];
    char DNI[10];
    int edad;
};

void introducir(Persona &p);
void visualizar(Persona p);

int main() {
    Persona unaPersona;
    introducir(unaPersona);
    visualizar(unaPersona);
    return 0;
}

void introducir(Persona &p) {
    cin >> p.nombre;
    cin >> p.DNI;
    cin >> p.edad;
}

void visualizar(Persona p) {
    cout << p.nombre;
    cout << p.DNI;
    cout << p.edad;
}
```

En este caso, `introducir` modifica directamente los valores de la estructura `unaPersona` porque se pasa por referencia, mientras que `visualizar` solo lee los valores.

## ðŸ“š Ejemplo prÃ¡ctico completo

Definamos una estructura mÃ¡s compleja para representar un vehÃ­culo. En este caso, incluiremos una uniÃ³n para manejar diferentes unidades de peso:

```c++ frame="terminal"
struct Vehiculo {
    char tipo[50];
    char marca[50];
    int numRuedas;
    float precio;
    union {
        float pesoKg;
        float pesoToneladas;
    } peso;
};

int main() {
    Vehiculo v;
    cout << "Introduce el tipo: ";
    cin >> v.tipo;
    cout << "Introduce la marca: ";
    cin >> v.marca;
    cout << "Introduce el nÃºmero de ruedas: ";
    cin >> v.numRuedas;
    cout << "Introduce el precio: ";
    cin >> v.precio;
    cout << "Introduce el peso en kg: ";
    cin >> v.peso.pesoKg;

    cout << "VehÃ­culo: " << v.tipo << ", " << v.marca << ", Precio: " << v.precio << "â‚¬\n";
    return 0;
}
```
