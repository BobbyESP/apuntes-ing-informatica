---
title: Tema 6 - Depuraci√≥n y Pruebas
description: Errores, pruebas, caja blanca, caja negra, estrategias de depuraci√≥n...
---

En el desarrollo de software, es crucial probar el software implementado y corregir cualquier error presente. Un programa no se considera correcto hasta que se haya verificado, es decir, hasta que se hayan realizado pruebas exitosas que abarquen todos los escenarios posibles y se hayan examinado los resultados de su ejecuci√≥n.

## ‚ùå Tipos de Errores

Los errores en programaci√≥n son inevitables, pero comprender sus diferentes tipos puede ayudarte a detectarlos y corregirlos de manera m√°s eficiente. Existen tres principales tipo:

### **1. Errores de Compilaci√≥n**

- Estos errores, tambi√©n conocidos como errores de sintaxis, ocurren cuando el compilador no puede entender el c√≥digo que has escrito.
- Esto puede deberse a un error tipogr√°fico, como olvidar un punto y coma al final de una l√≠nea de c√≥digo, o a un uso incorrecto de la sintaxis de la linguaje de programaci√≥n.
- El compilador detectar√° estos errores y detendr√° el proceso de compilaci√≥n, impidiendo que el programa objetivo se genere.
- Generalmente, los errores de compilaci√≥n son f√°ciles de identificar y corregir, ya que el compilador suele proporcionar informaci√≥n espec√≠fica sobre la ubicaci√≥n y la naturaleza del error.

### **2. Errores de Ejecuci√≥n**

- Los errores de ejecuci√≥n ocurren durante la ejecuci√≥n del programa, despu√©s de que ha sido compilado con √©xito.
- Se producen cuando el programa intenta realizar una operaci√≥n que no est√° permitida o no es posible, como dividir entre cero.
- Cuando se produce un error de ejecuci√≥n, el programa se detiene y muestra un mensaje de error que puede ayudarte a identificar la causa del problema. Normalmente se impide que el programa contin√∫e ejecut√°ndose.
- Algunos ejemplos comunes de errores de ejecuci√≥n incluyen acceder a una posici√≥n de memoria no v√°lida, intentar abrir un archivo que no existe o intentar realizar una operaci√≥n matem√°tica inv√°lida.

### **3. Errores L√≥gicos**

- Los errores l√≥gicos son los m√°s dif√≠ciles de detectar y corregir, ya que el programa se compila y ejecuta sin problemas, pero produce resultados incorrectos o no deseados.
- Estos errores se deben a errores en la l√≥gica del algoritmo (s√≠, es tu problema ü§ë), como un error en una f√≥rmula matem√°tica o una condici√≥n incorrecta en una estructura de control.
- Para detectar errores l√≥gicos, es necesario realizar pruebas exhaustivas del programa con diferentes conjuntos de datos de entrada y verificar cuidadosamente los resultados obtenidos.
- Algunos ejemplos de errores l√≥gicos incluyen el uso de un operador incorrecto en una expresi√≥n, olvidar actualizar una variable dentro de un bucle o no
  considerar todos los casos posibles en una estructura de selecci√≥n.

Obivamente la experiencia del programador, el uso de metodolog√≠as de desarrollo adecuadas, el dise√±o de subprogramas independientes y la atenci√≥n a los detalles
son factores que pueden influir en la cantidad y la gravedad de los errores.

La inclusi√≥n de instrucciones para mostrar el valor de las variables en puntos espec√≠ficos del programa (como `cout`), el uso de puntos de ruptura (`breakpoints`) para
detener la ejecuci√≥n del programa en determinados puntos y el an√°lisis del c√≥digo para identificar posibles errores l√≥gicos son pr√°cticas muy recomendadas a la
hora de encontrar errores y ver que el funcionamiento es el deseado.

## ‚úÖ Pruebas

Para garantizar la calidad del software, se llevan a cabo pruebas exhaustivas que implican la ejecuci√≥n del programa con diversos datos de entrada para evaluar
su comportamiento y resultados. Estas pruebas se dise√±an para detectar errores y asegurar que el software cumple con los requisitos especificados.

Existen dos metodolog√≠as principales para las pruebas de software:

### ‚¨ú Pruebas de Caja Blanca

Tambi√©n conocidas como pruebas estructurales, las pruebas de caja blanca se basan en el conocimiento de los detalles internos de implementaci√≥n y las rutas
de ejecuci√≥n del software. En este tipo de pruebas, se escriben casos de prueba espec√≠ficos para verificar las rutas l√≥gicas, bucles, estructuras de decisi√≥n
y conjuntos de condiciones del programa.

Las principales t√©cnicas para crear casos de prueba de caja blanca son:

- **Cobertura de caminos:** Esta t√©cnica busca ejecutar todos los caminos posibles dentro del programa. Se requiere un conjunto de casos de prueba
  para asegurar que cada camino se recorra al menos una vez, cubriendo tanto las condiciones verdaderas como las falsas.
- **Pruebas de condiciones:** En esta t√©cnica, se eval√∫a cada parte de una condici√≥n para determinar si se cumple o no. Se crean casos de prueba
  para cada operando l√≥gico, verificando si la expresi√≥n resultante es verdadera o falsa.
- **Pruebas de bucles:** Estas pruebas se enfocan en las estructuras repetitivas del programa, asegur√°ndose de que no sean infinitas y funcionen correctamente.
  Se ejecutan casos de prueba para un n√∫mero determinado de iteraciones, incluyendo cero, una, dos, un n√∫mero menor al l√≠mite, y un n√∫mero mayor al l√≠mite, para evaluar el comportamiento del bucle en diferentes situaciones.

**Ejemplo:** Pruebas de caja blanca para una estructura de selecci√≥n.

```c++
int a, b, numVeces;
... // El resto del c√≥digo
if(numVeces > 0) {
    if (a < 0) {
        a *= 2;
    }
    if (b != 0) {
        b = 5;
    }
}
```

**Casos de prueba:**

1. **COBERTURA DE CAMINOS** y **PRUEBA DE CONDICIONES**

   - `a = -5, b = 0`: Condici√≥n `a` verdadera, condici√≥n `b` falsa.
   - `a = 3, b = 8`: Condici√≥n `a` falsa, condici√≥n `b` verdadera.

2. **PRUEBA DE BUCLES**
   - Si `numVeces > 0` se cumple, se ejecutar√°n las instrucciones del bucle.
   - Si `numVeces <= 0`, las instrucciones del bucle nunca se ejecutar√°n.

### ‚¨õ Pruebas de Caja Negra

Las pruebas de caja negra, tambi√©n llamadas pruebas funcionales, se realizan desde la perspectiva del usuario. Se centran en la correcta ejecuci√≥n del software
en t√©rminos de tiempo y precisi√≥n, sin considerar los detalles internos de implementaci√≥n. Se enfocan en las funciones espec√≠ficas del software y su comportamiento observable.

Dos ejemplos de pruebas de caja negra son:

- **Pruebas de integraci√≥n:** Estas pruebas verifican la interacci√≥n entre diferentes m√≥dulos del software. Se combinan los m√≥dulos y
  se prueban como una unidad para asegurar que funcionan correctamente en conjunto.
- **Pruebas beta:** En esta etapa, se proporciona una versi√≥n preliminar del software a un grupo espec√≠fico de usuarios, generalmente expertos, para que la
  prueben en un entorno real. Se recopilan comentarios y sugerencias de los usuarios para mejorar la versi√≥n final del software.

**M√©todos para encontrar datos de prueba que conduzcan a errores:**

- **Partici√≥n equivalente:** Divide los par√°metros de entrada en clases de datos, llamadas clases de equivalencia. Se asume que cualquier elemento dentro de
  una clase de equivalencia es representativo del resto del conjunto. Se identifican clases de equivalencia v√°lidas (generan resultados esperados) e inv√°lidas (generan resultados inesperados)
  para crear casos de prueba.
- **Valores de prueba extremos:** Se utilizan valores en los l√≠mites del rango de entrada para verificar el comportamiento del software en situaciones extremas.
  Es una t√©cnica complementaria a la partici√≥n equivalente.

#### Ejemplos
**1er ejemplo:** Clases de equivalencia para un contador de horas en un d√≠a.

| Casos           | Valor | Clase v√°lida       | Clases inv√°lidas           |
| --------------- | ----- | ------------------ | -------------------------- |
| contador entero | `x`   | `1 <= valor <= 24` | `valor < 1` y `valor > 24` |

**2do ejemplo:** Casos de prueba de valores extremos para una variable que indica los **meses del a√±o**.

| Casos                                            | Valores (rango) |
| ------------------------------------------------ | --------------- |
| Valor en el l√≠mite inferior del rango de entrada | 1               |
| Valor uno por encima del l√≠mite inferior         | 2               |
| Valor v√°lido dentro del rango                    | 6               |
| Valor uno por debajo del l√≠mite superior         | 11              |
| Valor en el l√≠mite superior del rango de entrada | 12              |

## üîé Estrategia de Depuraci√≥n

La depuraci√≥n de un programa implica seguir una estrategia que permita evaluar primero los componentes m√°s simples y avanzar progresivamente
hasta probar todo el software como un conjunto.

**Pasos a seguir:**

- **Pruebas unitarias:** Se prueba cada funci√≥n o procedimiento individualmente. Pueden ser de caja blanca o de caja negra.
- **Pruebas de integraci√≥n:** Se combinan los subprogramas y se prueban en conjunto. Se suelen utilizar pruebas de caja negra.
- **Pruebas del sistema:** Se combina el programa completo con los componentes de hardware necesarios y se verifica el cumplimiento de
  los requisitos funcionales. Se emplean pruebas de caja negra.
- **Pruebas de aceptaci√≥n:** El usuario final comprueba si el software funciona seg√∫n lo previsto. Se utilizan pruebas de caja negra.
