---
title: Tema 8 - Arrays y matrices
description: Arrays y matrices en C/C++, definici칩n, uso, ejemplos...
---
import { Aside  } from "@astrojs/starlight/components";

## 游닀 Definici칩n

Un **array** es una estructura de datos est치tica que permite almacenar un conjunto finito y ordenado de datos homog칠neos (todos del mismo tipo). Cada dato almacenado se denomina **elemento** y puede ser accedido mediante un 칤ndice num칠rico que indica su posici칩n en el array.

### Caracter칤sticas principales

- **Homogeneidad:** Todos los elementos del array deben ser del mismo tipo, lo que facilita su tratamiento.
- **Memoria consecutiva:** Los datos se almacenan en posiciones consecutivas de memoria, permitiendo un acceso r치pido y eficiente.
- **Tama침o fijo:** El tama침o del array debe definirse en tiempo de compilaci칩n y no puede cambiar din치micamente durante la ejecuci칩n del programa.
- **Acceso por 칤ndice:** Cada elemento es accesible mediante un 칤ndice, comenzando en `0` para el primer elemento y terminando en `N-1` para el 칰ltimo, donde `N` es el tama침o del array.
- **Eficiencia:** Los arrays son ideales para trabajar con grandes vol칰menes de datos debido a su bajo coste en t칠rminos de sobrecarga.

---

## 游늶 Vectores (Arrays Unidimensionales)

Un **vector** es un array de una 칰nica dimensi칩n. Se utiliza para almacenar una lista lineal de elementos relacionados, como una serie de n칰meros o valores.

### Declaraci칩n

La sintaxis para declarar un vector en C++ es la siguiente:

```c++
// Sintaxis general
tipo nombreVector[TAM]; // TAM es el n칰mero de elementos
```

#### Ejemplo

```c++
float v1[5];
int v2[4];
```
En este caso, `v1` es un vector de 5 elementos de tipo `float` y `v2` un vector de 4 elementos de tipo `int`.

### Operaciones con vectores

#### 1. **Asignaci칩n e Inicializaci칩n**

La asignaci칩n permite establecer el valor de un elemento espec칤fico, mientras que la inicializaci칩n define valores para todos los elementos al momento de la declaraci칩n:

```c++ frame="terminal"
// Asignaci칩n de un solo elemento
v[0] = 10;

// Inicializaci칩n completa
int v[5] = {1, 2, 3, 4, 5};

// Inicializaci칩n impl칤cita
float v[] = {2.5, 3.7, 1.4};
```

#### 2. **Lectura y Escritura**

Estas operaciones permiten interactuar con el usuario para introducir o mostrar datos almacenados en el vector:

```c++
for (int i = 0; i < TAM; i++) {
    cin >> v[i]; // Lectura
    cout << v[i] << " "; // Escritura
}
```

#### 3. **Recorrido**

El recorrido implica procesar todos los elementos del vector mediante bucles. Ejemplo:

```c++
for (int i = 0; i < TAM; i++) {
    cout << "Elemento " << i << ": " << v[i] << endl;
}
```

#### 4. **Actualizaci칩n**

La actualizaci칩n permite modificar o reorganizar los elementos del vector. Por ejemplo, insertar un valor en una posici칩n espec칤fica:

```c++
if (numElementos < TAM) {
    for (int i = numElementos; i > pos; i--) {
        v[i] = v[i-1];
    }
    v[pos] = nuevoValor;
    numElementos++;
}
```

---

## 游늵 Matrices (Arrays Bidimensionales)

Una **matriz** es un array bidimensional que puede representarse como una tabla o rejilla. Es 칰til para almacenar datos relacionados en filas y columnas, como tablas de datos o im치genes.

### Declaraci칩n

La sintaxis para declarar matrices es:

```c++
// Sintaxis general
tipo nombreMatriz[filas][columnas];
```

#### Ejemplo

```c++
int matriz[3][4];
float matriz2[2][2] = {{1.1, 2.2}, {3.3, 4.4}};
```
En este caso, `matriz` es una matriz de 3 filas y 4 columnas de tipo entero.

### Operaciones con matrices

#### 1. **Asignaci칩n e Inicializaci칩n**

Al igual que los vectores, se pueden asignar valores directamente o inicializar toda la matriz:

```c++
matriz[0][1] = 5;

// Inicializaci칩n completa
tipo m[2][3] = {{1, 2, 3}, {4, 5, 6}};
```

#### 2. **Lectura y Escritura**

Utilizamos bucles anidados para procesar todos los elementos de la matriz:

```c++
for (int i = 0; i < filas; i++) {
    for (int j = 0; j < columnas; j++) {
        cin >> matriz[i][j];
        cout << matriz[i][j] << " ";
    }
    cout << endl;
}
```

#### 3. **Recorrido**

El recorrido puede ser por filas o columnas, dependiendo de la necesidad. Ejemplo:

```c++
for (int i = 0; i < filas; i++) {
    for (int j = 0; j < columnas; j++) {
        cout << "Elemento en [" << i << "][" << j << "]: " << matriz[i][j] << endl;
    }
}
```

### Ventajas de las matrices

- Organizaci칩n clara de datos en filas y columnas.
- F치cil representaci칩n de datos bidimensionales.
- Acceso eficiente mediante 칤ndices.

---

## 游늻 Arrays Multidimensionales

Los **arrays multidimensionales** permiten representar datos en m치s de dos dimensiones, como cubos o hipercubos de datos.

### Declaraci칩n

```c++
// Sintaxis general
tipo nombreArray[dim1][dim2]...[dimN];

// Ejemplo
double cubo[3][3][3];
```

El acceso a los elementos requiere especificar 칤ndices para cada dimensi칩n:

```c++
cubo[1][2][0] = 4.5;
```

### Uso y ejemplos

Estos arrays son 칰tiles en aplicaciones complejas como simulaciones cient칤ficas, gr치ficos 3D o an치lisis de datos.

---

## 游닓 Arrays como par치metros

Los arrays pueden ser pasados como argumentos a funciones. En C++, por defecto, los arrays se pasan por referencia, lo que significa que los cambios realizados en la funci칩n se reflejan en el array original.

### Declaraci칩n de funciones con arrays

```c++
// Declaraci칩n de la funci칩n
tipo funcion(tipo array[]);

// Ejemplo
float calcularMedia(float datos[], int TAM);
```

#### Ejemplo completo

```c++ frame="terminal"
#include <iostream>
using namespace std;

#define TAM 5

float calcularMedia(float datos[], int TAM) {
    float suma = 0.0;
    for (int i = 0; i < TAM; i++) {
        suma += datos[i];
    }
    return suma / TAM;
}

int main() {
    float datos[TAM] = {2.8, 5.6, 4.3, 9.7, 1.2};
    float media = calcularMedia(datos, TAM);
    cout << "La media es: " << media << endl;
    return 0;
}
```
<Aside type="caution">Los arrays son estructuras fundamentales que permiten manejar grandes vol칰menes de datos de manera eficiente.
Sin embargo, su uso inadecuado puede provocar errores dif칤ciles de detectar, como accesos fuera de los l칤mites permitidos.
Por ello, es importante verificar siempre los rangos de 칤ndices y asegurar la correcta inicializaci칩n de los elementos antes de su uso.</Aside>