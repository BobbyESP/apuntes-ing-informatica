---
title: Tema 1 - Introducción a la arquitectura de computadores
description: Apuntes del tema 1 de la asignatura Arquitectura de Computadores I
---

## 1. Introducción y Objetivos del Curso

### ¿Qué es Arquitectura de Computadoras?

La arquitectura de computadoras estudia **cómo se diseñan y organizan los sistemas informáticos**. Se centra tanto en la **estructura**—la forma en que se conectan los componentes físicos—como en el **funcionamiento** o la forma en que esos componentes operan en conjunto para procesar información.  
*Imagina una ciudad:* los edificios (componentes) tienen su diseño (estructura) y, al mismo tiempo, deben interactuar (funcionamiento) para que la ciudad funcione de manera ordenada.

### ACI vs. ACII (Conceptual vs. Real)

- **ACI (Computadora Sencilla):**  
  En este curso, se introduce un modelo *conceptual* simplificado de una computadora, en el que se destacan los componentes esenciales:  
  - **UCP (Unidad Central de Procesamiento)**
  - **MP (Memoria Principal)**
  - **ME/S (Módulos de Entrada/Salida)**  
  Todos estos elementos están conectados por un **bus del sistema**, que actúa como la “autopista” por donde circulan datos e instrucciones. Este modelo nos permite comprender los principios básicos sin perdernos en detalles excesivos.

- **ACII (Computadora Real):**  
  Más adelante se abordarán arquitecturas reales (como el chipset Intel X79) que incorporan múltiples buses, jerarquías de memoria y otros elementos complejos. La diferencia clave es el **nivel de abstracción**: en el modelo conceptual se simplifican muchos detalles que, en la práctica, son esenciales para el funcionamiento de equipos reales.

### Objetivos Clave del Curso

1. **Traducción y Ejecución:**  
   Analizar cómo un programa escrito en un lenguaje de alto nivel (por ejemplo, C o Java) se transforma en señales eléctricas que la computadora puede ejecutar. Esto involucra el trabajo de **compiladores**, **ensambladores** y la conversión a **lenguaje máquina**.

2. **Interfaz Hardware-Software:**  
   Comprender el punto de encuentro entre el software y el hardware, principalmente a través del **Conjunto de Instrucciones (ISA)**, que define las órdenes que la computadora puede interpretar directamente.

3. **Desempeño (Performance):**  
   Investigar qué factores determinan que un programa se ejecute rápida o lentamente, considerando aspectos desde la calidad del código hasta la eficiencia en la traducción a lenguaje máquina y las características del hardware.

4. **Mejoras de Hardware:**  
   Estudiar las técnicas y “trucos” que los diseñadores utilizan para incrementar la velocidad de procesamiento y reducir el consumo de energía en los computadores.

5. **Paralelismo:**  
   Reflexionar sobre la evolución de procesadores secuenciales a sistemas con múltiples “cerebros” (núcleos) y las implicaciones que esto tiene en la forma en que se escribe y ejecuta el software.

6. **Evolución:**  
   Analizar cómo han cambiado las arquitecturas a lo largo del tiempo, adaptándose a nuevas tecnologías y necesidades.

---

## 2. La omnipresencia de los computadores

### Tipos de Computadores

Las computadoras están en todas partes y se pueden clasificar en dos grandes grupos:

- **Visibles/Tradicionales:**  
  Equipos que se perciben en la vida diaria, como:
  - **Sobremesa (Desktop)**
  - **Portátiles (Laptops)**
  - **Servidores**, incluidos aquellos que impulsan la “nube” o **cloud**.

- **Invisibles/Embebidos (Embedded Systems):**  
  Estas son computadoras “escondidas” dentro de otros dispositivos y diseñadas para realizar funciones específicas.  
  **Ejemplos:**  
  - Automóviles (control de motor, sistemas de frenos ABS, airbags, GPS)  
  - Teléfonos móviles  
  - Microondas, lavadoras, relojes inteligentes  
  - Equipos médicos, juguetes, y hasta dispositivos tan sorprendentes como zapatillas deportivas o inodoros inteligentes.  

### Características de los Sistemas Embebidos

- **Integración:** Combinan hardware y software específico para una tarea.
- **Producción masiva:** Se fabrican en cantidades muy elevadas (miles de millones anualmente).
- **Dependencia del entorno:** Interactúan con el mundo real mediante sensores (para captar datos) y actuadores (para generar respuestas).
- **Restricciones de tiempo real:** Deben responder a eventos externos en plazos muy cortos (por ejemplo, el despliegue de un airbag en milisegundos).

#### Organización Típica de un Sistema Embebido

Un procesador central se conecta con:
- **Memoria:** Para almacenar código y datos.
- **Interfaz Humana:** Como botones o pantallas pequeñas.
- **Sensores:** A través de conversores Analógico-Digital (A/D).
- **Actuadores/Indicadores:** Con conversores Digital-Analógico (D/A).
- **Lógica personalizada:** Hardware diseñado para tareas específicas.
- **Puerto de diagnóstico:** Usado para pruebas y depuración.

---

## 3. Especificaciones Técnicas: Los Componentes Clave de una Computadora Real

Las diapositivas muestran en detalle la “estructura interna” de computadoras como portátiles y desktops. No es necesario memorizar cada especificación, pero es importante comprender la función y variabilidad de los siguientes componentes:

### Procesador (CPU)

- **Especificaciones:**  
  - **Marca y Modelo:** Por ejemplo, Intel Core i7 o i9.
  - **Generación y Velocidad (GHz):** Aunque más GHz no siempre significa mayor velocidad. La cantidad de núcleos y la arquitectura interna también juegan un rol fundamental.
  - **Núcleos/Hilos:** Ejemplos comunes son 2/4, 6/12 o 8/16.
  - **Caché y Tecnología de Fabricación:** La caché mejora la velocidad de acceso a datos y la tecnología (medida en nm) indica el tamaño de los transistores.

- **Tecnologías Avanzadas:**  
  - **Turbo Boost:** Permite aumentar la velocidad del procesador temporalmente.
  - **Hyper-Threading:** Habilita que un núcleo maneje dos hilos de ejecución simultáneamente.

### Memoria RAM

- **Características:**  
  - **Capacidad:** Medida en GB.
  - **Tipo y Velocidad:** DDR3, DDR4, y la velocidad se mide en MHz.  
La RAM es volátil, es decir, pierde su contenido al apagar el equipo.

### Almacenamiento

- **Tipos:**  
  - **HDD (Disco Duro Mecánico):** Usa platos magnéticos.
  - **SSD (Unidad de Estado Sólido):** Utiliza memoria flash, ofreciendo mayor velocidad.
  - **NVMe:** Interfaz más rápida que SATA, ideal para SSDs.
  - **eMMC:** Almacenamiento integrado en dispositivos móviles (bajo rendimiento en relación a los anteriores).

### Tarjeta Gráfica (GPU)

- Fundamental para aplicaciones como juegos, diseño gráfico e inteligencia artificial.  
- La GPU posee su propia memoria (por ejemplo, GDDR) para procesar gráficos de manera eficiente.

### Conectividad y Puertos

Incluyen conexiones para:
- **USB:** Con diferentes tipos y velocidades.
- **HDMI, Ethernet (LAN), Wi-Fi y Bluetooth:** Esenciales para la transferencia de datos y conexión a redes.

### Relación Precio/Desempeño

Existe una jerarquía clara:
- **Sistemas embebidos:** Baratos y con bajo rendimiento.
- **Supercomputadoras:** Extremadamente costosas y potentes.
- **PCs personales, estaciones de trabajo y servidores:** Ocupan una posición intermedia, pero comparten los principios fundamentales de la arquitectura.

---

## 4. Componentes Principales y la Importancia de la Abstracción

### Sistema Típico en un PC

Un PC de sobremesa se compone de elementos visibles (monitor, teclado, torre) y de un componente central: la **Placa Base (Motherboard)**.

### La Placa Base

Se la puede considerar el “sistema nervioso central” ya que conecta todos los componentes. Entre sus funciones se destacan:
- Proveer un **zócalo** para la CPU.
- Ofrecer **ranuras** para la memoria RAM y para tarjetas de expansión (como gráfica, sonido, red).
- Incluir el **chipset**, que gestiona la comunicación entre la CPU, la RAM y otros periféricos.
- Contar con conectores para almacenamiento (SATA, M.2) y puertos de entrada/salida.
- Incluir el **BIOS/UEFI**, que inicia el sistema, y la **batería CMOS** para mantener la configuración.

### El Concepto de Abstracción

Dado que es imposible diseñar un sistema pensando en cada transistor (¡son miles de millones!), se utilizan **niveles de abstracción**. Esto significa que se agrupan componentes en módulos con interfaces definidas sin exponer detalles internos.  
**Analogía:** Es similar a cómo usamos una aplicación en nuestro teléfono sin conocer el código fuente que la respalda; solo necesitamos saber qué funciones ofrece.

#### Jerarquía de Abstracción

1. **Transistor (MOSFET):** El interruptor básico (0 o 1).  
2. **Puerta Lógica (Gate):** Combina transistores para ejecutar funciones lógicas (por ejemplo, AND, OR, NOT).  
3. **Celda:** Un bloque funcional sencillo, como un sumador pequeño, formado por varias puertas.  
4. **Módulo:** Una unidad funcional mayor (por ejemplo, una ALU o un registro) que integra muchas celdas.  
5. **Circuito Integrado (IC / Chip):** Puede ser una CPU o memoria, compuesta por miles o millones de módulos.  
6. **Placa de Circuito (Circuit Board):** Como la placa base, que agrupa varios chips.  
7. **Sistema Completo (PC):** La integración de todos los componentes (hardware y software) en un sistema funcional.

Cada nivel superior utiliza los servicios del nivel inferior sin necesidad de conocer su funcionamiento interno, solo la interfaz que ofrece.

---

## 5. Niveles de un Sistema Informático

Los computadores se pueden ver como una “pila” de niveles, donde cada nivel traduce o interpreta las operaciones del anterior. Esto permite una separación de responsabilidades y una mayor modularidad en el diseño.

### Modelo de Tanenbaum / Niveles Comunes

1. **Nivel 0: Lógica Digital**  
   El hardware físico: compuertas lógicas, cables y voltajes que implementan operaciones matemáticas básicas.

2. **Nivel 1: Control / Microarquitectura**  
   La unidad de control de la CPU interpreta las instrucciones. Puede ser implementada con circuitos específicos o mediante un pequeño programa interno (microcódigo).

3. **Nivel 2: Lenguaje Máquina / ISA (Instruction Set Architecture)**  
   Es el conjunto de instrucciones que la CPU entiende directamente, funcionando como la **interfaz** entre hardware y software de bajo nivel.

4. **Nivel 3: Sistema Operativo (SO)**  
   Software que administra los recursos (CPU, memoria, E/S) y coordina la ejecución de programas. Muchas de sus funciones dependen de las instrucciones del nivel anterior.

5. **Nivel 4: Lenguaje Ensamblador (Assembly)**  
   Representa de forma simbólica el lenguaje máquina, facilitando la programación cercana al hardware.

6. **Nivel 5: Lenguajes de Alto Nivel**  
   Lenguajes como C, Java o Python, que abstraen detalles del hardware y se traducen a niveles inferiores mediante compiladores o intérpretes.

7. **Nivel 6: Nivel de Usuario**  
   Aplicaciones y programas con los que interactuamos a diario, como navegadores web, procesadores de texto o juegos.

### Proceso de Traducción

El camino desde un programa escrito en un lenguaje de alto nivel hasta su ejecución en hardware es el siguiente:

```
Programa en Lenguaje Alto Nivel → (Compilador) → Programa en Ensamblador → (Ensamblador) → Programa en Lenguaje Máquina (Binario) → (Interpretación por Hardware/Microcódigo) → Señales de Control → Ejecución
```

### Visión HW/SW

Existe un espectro que va desde el software de aplicación hasta los componentes electrónicos. La **Arquitectura** (definida a través de la ISA) muestra el “qué” puede hacer el sistema, mientras que la **Organización/Microarquitectura** describe el “cómo” se implementa internamente el hardware.

---

## 6. ISA: El Contrato entre Hardware y Software

### ¿Qué es la ISA?

La **Instruction Set Architecture (ISA)** define todo lo que un programador necesita conocer para escribir código que la computadora pueda interpretar. Esto incluye:

- Instrucciones disponibles.
- Tipos de datos.
- Registros y modos de direccionamiento.
- Formato de las instrucciones.

### Importancia de la ISA

- **Abstracción Fundamental:** Separa el diseño del software del hardware específico.
- **Compatibilidad:** Permite que diferentes procesadores, aun con implementaciones variadas, puedan ejecutar el mismo software si comparten la misma ISA.
- **Normalización:** Define de forma exacta el formato binario de las instrucciones.

### RISC vs. CISC

Dos filosofías en el diseño de ISAs:

- **CISC (Complex Instruction Set Computer):**  
  - **Objetivo:** Facilitar la programación reduciendo el número de instrucciones necesarias en un programa.
  - **Características:** Muchas instrucciones, algunas muy complejas, y diversos modos de direccionamiento. El código resultante es generalmente más compacto.
  - **Desventajas:** Hardware de control complejo y, en algunos casos, las instrucciones más utilizadas pueden verse ralentizadas debido a su complejidad.  
  *Ejemplo:* La arquitectura x86.

- **RISC (Reduced Instruction Set Computer):**  
  - **Objetivo:** Simplificar el hardware para lograr mayor velocidad, centrándose en las instrucciones más comunes.
  - **Características:** Pocas instrucciones, simples, con formato fijo y orientadas a operaciones entre registros (utilizando técnicas de *Load/Store*).
  - **Ventajas:** Hardware más simple, lo que facilita técnicas como el *pipelining* para solapar la ejecución de instrucciones.  
  *Ejemplo:* ARM o MIPS.  
  - **Nota:** Actualmente, la distinción entre RISC y CISC es menos marcada; por ejemplo, los procesadores x86 usan internamente técnicas similares a RISC.

---

## 7. Arquitecturas Fundamentales: Von Neumann y Harvard

### La Propuesta de John Von Neumann

John Von Neumann popularizó el concepto del **Programa Almacenado**.  
- **Problema en máquinas anteriores (como el ENIAC):** Cambiar de tarea requería reconfigurar físicamente la máquina.  
- **Solución de Von Neumann:** Almacenar tanto las instrucciones como los datos en la misma memoria (en formato binario). Esto permitió cambiar de tarea simplemente cargando un programa diferente, haciendo el sistema mucho más flexible.

### Arquitectura Von Neumann

- **Componentes:**  
  - CPU (con su Unidad de Control, ALU y registros).  
  - Memoria Principal unificada.  
  - Unidades de Entrada/Salida y un sistema de buses para la interconexión.
- **Característica clave:**  
  Utiliza el **mismo bus** para acceder tanto a instrucciones como a datos.
- **Ventaja y Desventaja:**  
  La simplicidad es una ventaja, pero el **cuello de botella de Von Neumann** surge cuando la CPU tiene que esperar, ya que no puede buscar instrucciones y datos al mismo tiempo.

### Arquitectura Harvard

- **Concepto:**  
  Utiliza memorias y buses separados para instrucciones y datos.
- **Ventaja:**  
  Permite acceder simultáneamente a la siguiente instrucción y a los datos necesarios para la instrucción actual, eliminando el cuello de botella.
- **Uso Común:**  
  Se emplea en microcontroladores y procesadores de señales, donde el flujo constante de datos es crítico.  
- **Nota:**  
  Muchas CPUs modernas aplican una arquitectura Harvard modificada en sus cachés (por ejemplo, cachés separadas L1 para datos e instrucciones), aunque a nivel externo se comporten como un sistema Von Neumann.

---

## 8. Componentes Detallados (Revisión de la Estructura Interna)

Este apartado revisa de manera más profunda algunos de los componentes internos de una computadora:

- **Memoria Principal (RAM):**  
  Almacena programas y datos que están en uso. Se accede a ella mediante direcciones. Se organiza en celdas (cada una guarda bits) y su capacidad (por ejemplo, 8GB) y el tamaño de palabra (como 64 bits) son fundamentales.

- **CPU – ALU (Unidad Aritmético-Lógica):**  
  Se encarga de realizar operaciones matemáticas (suma, resta, etc.) y lógicas (AND, OR, XOR, NOT).

- **CPU – Unidad de Control:**  
  Es el “director de orquesta” del sistema. Sus funciones incluyen:
  - Buscar instrucciones en la memoria.
  - Decodificar las instrucciones para entender qué se debe hacer.
  - Generar señales de control para coordinar a la ALU, registros y la memoria.
  - Gestionar el flujo de datos entre los distintos componentes.

- **CPU – Registros:**  
  Son pequeñas unidades de memoria ubicadas dentro de la CPU. Su gran velocidad las hace ideales para almacenar datos temporales, direcciones o el estado del procesador (por ejemplo, el contador de programa o el registro de instrucciones).

- **Unidades de Entrada/Salida (E/S):**  
  Permiten la comunicación entre el usuario y el sistema. Ejemplos incluyen el teclado, ratón, pantalla, disco duro, red e impresoras. Su conexión se realiza mediante módulos de E/S o controladores que median la interacción con la CPU y la memoria.

- **Sistema de Interconexión (Buses):**  
  Es el conjunto de cables o líneas que interconectan todos los componentes para la transferencia de datos, direcciones y señales de control. En sistemas simples se utiliza un único bus, mientras que en sistemas más complejos se emplean múltiples buses jerárquicos (como un bus dedicado para la memoria y otro para los dispositivos de E/S, por ejemplo, PCIe).

---

## 9. Historia y Evolución de la Computación

La evolución de las computadoras se puede clasificar en generaciones, donde cada una se caracteriza por la tecnología predominante:

- **Generación 0 (< 1945):**  
  Computadoras mecánicas o electromecánicas (por ejemplo, basadas en relés).

- **Generación 1 (1945-1954):**  
  Uso de **tubos de vacío** (ejemplos: ENIAC, UNIVAC). Estas máquinas eran enormes, generaban mucho calor y eran poco confiables. Aquí surge el concepto de Von Neumann.

- **Generación 2 (1954-1963):**  
  Introducción de **transistores**, que hicieron los equipos más pequeños, fiables y asequibles. Surgieron minicomputadoras, lenguajes de alto nivel (como Fortran) y compiladores, junto con los primeros sistemas operativos y la microprogramación.

- **Generación 3 (1964-1971):**  
  Uso de **circuitos integrados** (SSI/MSI) con pocas puertas por chip. Ejemplos incluyen el IBM System/360 y el DEC PDP-8. Se introdujeron conceptos como la multiprogramación y la memoria caché.

- **Generación 4 (1972-1987):**  
  Desarrollo de la tecnología **VLSI (Very Large Scale Integration)**, con miles o millones de transistores por chip. Aparecen los microprocesadores (como el Intel 4004 o el 8080) y las computadoras personales (Apple II, IBM PC). Se reemplazan tecnologías antiguas por memorias semiconductoras y se populariza la arquitectura RISC.

- **Generación 5 (1988-Presente):**  
  Avances en **ULSI/SoC (System on Chip)** con un fuerte enfoque en el paralelismo, multi-núcleo, GPUs, sistemas embebidos potentes y redes, adaptándose a la creciente demanda de procesamiento.

**IBM PC XT (1983):**  
Fue un hito que consolidó el uso de la arquitectura x86 y el sistema operativo MS-DOS, estableciendo un estándar que dominaría el mercado durante décadas.

---

## 10. Tendencias de Rendimiento y los "Muros"

A medida que los procesadores se han ido perfeccionando, se han encontrado ciertos límites físicos y tecnológicos:

### Ley de Moore

Una observación empírica realizada por Gordon Moore en 1965 que indica que el número de transistores en un chip se duplica aproximadamente cada 18-24 meses (manteniendo el coste). Esto ha impulsado el progreso exponencial en la computación, tanto en CPUs como en memorias DRAM.

Actualmente, se observa que la Ley de Moore está experimentando una desaceleración notable, acercándose incluso al punto en que algunos la consideran obsoleta. Sin embargo, a pesar de este enfriamiento, sigue siendo un motor fundamental para la innovación tecnológica. A lo largo de las décadas, esta ley ha sido un referente crucial que ha impulsado el desarrollo continuo de la industria de los semiconductores.

### Rendimiento Single-Core y sus Limitaciones

Durante mucho tiempo, el aumento de la velocidad de un procesador se basaba en incrementar la *frecuencia de reloj* (medida en GHz). Sin embargo, alrededor de 2004-2005, este método alcanzó un límite debido a problemas como el aumento excesivo de energía consumida y la generación de calor.

### El Muro de la Potencia (Power Wall)

Incrementar la frecuencia no solo aumenta la velocidad, sino también el consumo de energía y la producción de calor. La densidad de potencia (watts por cm²) alcanzó niveles insostenibles, limitando la capacidad de enfriamiento y estancando la frecuencia de operación en torno a los 3-5 GHz.

### El Muro de la Memoria (Memory Wall)

La velocidad de procesamiento de la CPU ha crecido mucho más rápido que la velocidad de acceso a la memoria principal (DRAM). Esto genera una brecha en la que la CPU puede ejecutar cientos o miles de instrucciones en el tiempo que tarda en acceder a la memoria. Aunque la implementación de cachés ayuda, no elimina este cuello de botella.

### Límites del Paralelismo a Nivel de Instrucción (ILP)

Las técnicas que permiten a un solo núcleo ejecutar varias instrucciones por ciclo (como el *pipelining* y la ejecución superescalar) también alcanzaron un punto de rendimientos decrecientes, ya que la complejidad añadida no siempre se traduce en beneficios proporcionales.

---

## 11. La Revolución Multi-núcleo

Cuando aumentar la velocidad de un solo núcleo ya no es viable, la solución ha sido integrar **múltiples núcleos** en un solo chip.  
- **Ventajas:**  
  Permite que el rendimiento global mejore al distribuir las tareas entre núcleos más simples y energéticamente eficientes.  
- **Tendencia Actual:**  
  Desde aproximadamente 2005, el incremento en el rendimiento se ha logrado principalmente añadiendo más núcleos (2, 4, 8, 16 o incluso cientos en GPUs y procesadores especializados).  
- **Desafío:**  
  El software debe estar preparado para aprovechar este paralelismo, lo cual implica una complejidad adicional en la programación de aplicaciones concurrentes.

---

## 12. Futuro y Desafíos de la Arquitectura de Computadoras

La evolución continúa, y junto con nuevas tecnologías surgen nuevos desafíos:

### Avances en Fabricación

Se sigue reduciendo el tamaño de los transistores (por ejemplo, 10nm, 7nm, 5nm y, en un futuro, posiblemente 1nm), lo que permite aumentar la densidad y el rendimiento, en línea con la Ley de Moore.

### Nuevas Tecnologías Emergentes

- **Chips 3D:**  
  Consiste en apilar capas de silicio (por ejemplo, colocar la memoria directamente sobre el procesador) para reducir distancias y aumentar el ancho de banda.

- **CNTFETs:**  
  Transistores basados en nanotubos de carbono, que pueden ofrecer mejoras en velocidad y eficiencia.

- **Spintronics:**  
  Aprovecha el "spin" del electrón, además de su carga, para realizar operaciones.

- **Computación Neuromórfica:**  
  Inspirada en el funcionamiento del cerebro humano, busca replicar la manera en que las neuronas procesan la información.

- **Computación Cuántica:**  
  Un paradigma radicalmente diferente para ciertos tipos de problemas, basado en las propiedades cuánticas de las partículas.

- **Computación Fotónica:**  
  Utiliza la luz en lugar de electrones para procesar y transmitir datos, lo que podría superar algunas de las limitaciones actuales.

### Desafíos de Seguridad: Bugs de Arquitectura

Recientemente se han descubierto vulnerabilidades como **Spectre** y **Meltdown**, que explotan características de optimización en los procesadores modernos (como la ejecución especulativa) para acceder a información sensible. Estos incidentes demuestran que las decisiones de diseño en la arquitectura pueden tener implicaciones de seguridad muy profundas.

---

## 13. Conclusiones Clave

- **Concepto General:**  
  La arquitectura de computadoras abarca desde el diseño conceptual hasta la implementación real de sistemas informáticos.  
- **Abstracción y Jerarquías:**  
  La utilización de niveles de abstracción y estructuras jerárquicas es esencial para manejar la complejidad del hardware moderno.  
- **Importancia de la ISA:**  
  La Instruction Set Architecture es el contrato fundamental entre el hardware y el software, permitiendo compatibilidad y normalización.  
- **Modelos de Arquitectura:**  
  Las arquitecturas Von Neumann y Harvard representan dos enfoques básicos que han evolucionado en los sistemas modernos.  
- **Evolución Tecnológica:**  
  Desde los tubos de vacío hasta los microprocesadores de alta densidad, la evolución ha sido impulsada por la Ley de Moore, aunque se han presentado desafíos como el muro de la potencia y el muro de la memoria.  
- **Paralelismo y el Futuro:**  
  La transición hacia procesadores multi-núcleo ha sido la respuesta a las limitaciones del rendimiento de un solo núcleo, abriendo la puerta a nuevas tecnologías y retos en programación y seguridad.